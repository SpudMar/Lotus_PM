// Lotus PM - Prisma Schema
// All table names are module-prefixed per coding conventions.
// All financial amounts stored as Int (cents) — never Float.
// Soft deletes only — never hard delete financial or participant records.
// REQ-016: Encryption at rest handled by AWS RDS + application layer.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ─────────────────────────────────────────────
// CORE MODULE — Authentication, Users, Audit
// ─────────────────────────────────────────────

model CoreUser {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String
  role          CoreRole  @default(ASSISTANT)
  phone         String?   // E.164 format — used for SMS notifications
  isActive      Boolean   @default(true)
  mfaEnabled    Boolean   @default(false)
  lastLoginAt   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  deletedAt     DateTime? // Soft delete

  // Auth relations (NextAuth)
  accounts      CoreAccount[]
  sessions      CoreSession[]

  // Audit trail — every action this user takes
  auditLogs     CoreAuditLog[]

  // Business relations
  assignedParticipants CrmParticipant[] @relation("AssignedPlanManager")
  approvedInvoices     InvInvoice[]     @relation("ApprovedBy")
  rejectedInvoices     InvInvoice[]     @relation("RejectedBy")
  commLogs             CrmCommLog[]
  submittedClaims      ClmClaim[]       @relation("ClaimSubmittedBy")
  outcomeClaims        ClmClaim[]       @relation("ClaimOutcomeBy")
  submittedBatches     ClmBatch[]       @relation("BatchSubmittedBy")
  inAppNotifications   NotifNotification[] @relation("UserNotifications")
  uploadedDocuments    DocDocument[]    @relation("UploadedDocuments")
  createdCorrespondence CrmCorrespondence[] @relation("CreatedCorrespondence")

  @@map("core_users")
}

enum CoreRole {
  GLOBAL_ADMIN
  PLAN_MANAGER
  ASSISTANT
  PARTICIPANT
}

model CoreAccount {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user CoreUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("core_accounts")
}

model CoreSession {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user CoreUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("core_sessions")
}

model CoreVerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("core_verification_tokens")
}

model CoreAuditLog {
  id         String   @id @default(cuid())
  userId     String
  action     String   // e.g. "invoice.approved", "participant.created"
  resource   String   // e.g. "invoice", "participant"
  resourceId String
  before     Json?    // State before change (no PII in logs — REQ-017)
  after      Json?    // State after change
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())

  user CoreUser @relation(fields: [userId], references: [id])

  @@index([resource, resourceId])
  @@index([userId])
  @@index([createdAt])
  @@map("core_audit_logs")
}

// ─────────────────────────────────────────────
// CRM MODULE — Participants, Providers, Comms
// ─────────────────────────────────────────────

model CrmParticipant {
  id                String    @id @default(cuid())
  ndisNumber        String    @unique
  firstName         String
  lastName          String
  dateOfBirth       DateTime
  email             String?
  phone             String?
  address           String?
  suburb            String?
  state             String?
  postcode          String?

  // Plan manager assignment
  assignedToId      String?
  assignedTo        CoreUser? @relation("AssignedPlanManager", fields: [assignedToId], references: [id])

  // Emergency contact
  emergencyContactName  String?
  emergencyContactPhone String?
  emergencyContactRel   String?

  // Metadata
  isActive          Boolean   @default(true)
  onboardedAt       DateTime  @default(now())
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  deletedAt         DateTime? // Soft delete — REQ-010

  // Relations
  plans             PlanPlan[]
  invoices          InvInvoice[]
  commLogs          CrmCommLog[]
  documents         DocDocument[]
  notifications     NotifNotification[]
  claims            ClmClaim[]
  correspondence    CrmCorrespondence[]

  @@index([ndisNumber])
  @@index([assignedToId])
  @@map("crm_participants")
}

model CrmProvider {
  id              String    @id @default(cuid())
  name            String
  abn             String    @unique
  email           String?
  phone           String?
  address         String?

  // NDIS provider registration
  ndisRegistered  Boolean   @default(true)
  registrationNo  String?

  // Bank details for ABA payment files
  bankBsb         String?
  bankAccount     String?
  bankAccountName String?

  isActive        Boolean   @default(true)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  deletedAt       DateTime?

  // Relations
  invoices        InvInvoice[]
  commLogs        CrmCommLog[]
  correspondence  CrmCorrespondence[]
  emails          CrmProviderEmail[]

  @@index([abn])
  @@map("crm_providers")
}

// Known sender email addresses for providers.
// Used by the auto-matching service to link inbound invoice emails to providers.
// A single email address can belong to only one provider (unique constraint).
// isVerified becomes true after a PM confirms the match a second time.
model CrmProviderEmail {
  id          String      @id @default(cuid())
  providerId  String
  provider    CrmProvider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  email       String      @unique  // One email → one provider only
  isVerified  Boolean     @default(false)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  @@index([providerId])
  @@map("crm_provider_emails")
}

model CrmCommLog {
  id            String           @id @default(cuid())
  type          CommType
  direction     CommDirection    @default(OUTBOUND)
  subject       String?
  body          String           @db.Text
  participantId String?
  providerId    String?
  userId        String           // Staff member who logged this

  participant   CrmParticipant?  @relation(fields: [participantId], references: [id])
  provider      CrmProvider?     @relation(fields: [providerId], references: [id])
  user          CoreUser         @relation(fields: [userId], references: [id])

  occurredAt    DateTime         @default(now())
  createdAt     DateTime         @default(now())

  @@index([participantId])
  @@index([providerId])
  @@map("crm_comm_logs")
}

enum CommType {
  EMAIL
  PHONE
  SMS
  IN_PERSON
  PORTAL_MESSAGE
  NOTE
}

enum CommDirection {
  INBOUND
  OUTBOUND
  INTERNAL
}

// Per-client correspondence hub — REQ-024, Part B
// Unified timeline of all communications per participant/provider.
model CrmCorrespondence {
  id            String               @id @default(cuid())
  type          CorrespondenceType

  subject       String?
  body          String               @db.Text

  // Sender / recipient addresses (email address or phone number)
  fromAddress   String?
  toAddress     String?

  // Optional links — one or more may be set
  participantId String?
  participant   CrmParticipant?      @relation(fields: [participantId], references: [id])

  providerId    String?
  provider      CrmProvider?         @relation(fields: [providerId], references: [id])

  invoiceId     String?
  invoice       InvInvoice?          @relation(fields: [invoiceId], references: [id])

  documentId    String?              // Link to DocDocument (no FK — optional future use)

  createdById   String?              // Staff user who created this (null = system/automation)
  createdBy     CoreUser?            @relation("CreatedCorrespondence", fields: [createdById], references: [id])

  metadata      Json?                // Extra context: s3Key, originalFilename, etc.

  createdAt     DateTime             @default(now())

  @@index([participantId, createdAt])
  @@index([providerId, createdAt])
  @@index([invoiceId])
  @@map("crm_correspondence")
}

enum CorrespondenceType {
  EMAIL_INBOUND
  EMAIL_OUTBOUND
  SMS_INBOUND
  SMS_OUTBOUND
  NOTE
  PHONE_CALL
}

// ─────────────────────────────────────────────
// PLAN MODULE — Plans, Budgets, Spending
// ─────────────────────────────────────────────

model PlanPlan {
  id              String     @id @default(cuid())
  participantId   String
  participant     CrmParticipant @relation(fields: [participantId], references: [id])

  // Plan dates
  startDate       DateTime
  endDate         DateTime
  reviewDate      DateTime?

  // PRODA reference
  prodaPlanId     String?    @unique

  status          PlanStatus @default(ACTIVE)
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  budgetLines     PlanBudgetLine[]
  invoices        InvInvoice[]
  fundingPeriods  PlanFundingPeriod[]

  @@index([participantId])
  @@index([status])
  @@map("plan_plans")
}

enum PlanStatus {
  ACTIVE
  EXPIRING_SOON
  EXPIRED
  UNDER_REVIEW
  INACTIVE
}

model PlanBudgetLine {
  id              String   @id @default(cuid())
  planId          String
  plan            PlanPlan @relation(fields: [planId], references: [id])

  // NDIS support category (01-15)
  categoryCode    String
  categoryName    String

  // All amounts in cents (Int) — REQ: never floats for money
  allocatedCents  Int
  spentCents      Int      @default(0)
  reservedCents   Int      @default(0) // Claimed but not yet paid

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  invoiceLines    InvInvoiceLine[]
  periodBudgets   PlanPeriodBudget[]

  @@unique([planId, categoryCode])
  @@index([planId])
  @@map("plan_budget_lines")
}

// ─────────────────────────────────────────────
// PLAN FUNDING PERIODS — S33 Non-Standard Periods (REQ-035)
// Logic deferred until Nicole confirms S33 details (DEC-003)
// ─────────────────────────────────────────────

model PlanFundingPeriod {
  id        String   @id @default(cuid())
  planId    String
  startDate DateTime
  endDate   DateTime
  label     String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  plan          PlanPlan           @relation(fields: [planId], references: [id], onDelete: Cascade)
  periodBudgets PlanPeriodBudget[]

  @@map("plan_funding_periods")
}

model PlanPeriodBudget {
  id              String   @id @default(cuid())
  fundingPeriodId String
  budgetLineId    String
  allocatedCents  Int
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  fundingPeriod PlanFundingPeriod @relation(fields: [fundingPeriodId], references: [id], onDelete: Cascade)
  budgetLine    PlanBudgetLine    @relation(fields: [budgetLineId], references: [id])

  @@unique([fundingPeriodId, budgetLineId])
  @@map("plan_period_budgets")
}

// ─────────────────────────────────────────────
// INVOICE MODULE — Processing Pipeline
// ─────────────────────────────────────────────

model InvInvoice {
  id              String        @id @default(cuid())
  // Nullable — email-ingested drafts arrive before participant/provider are identified
  participantId   String?
  providerId      String?
  planId          String?

  participant     CrmParticipant? @relation(fields: [participantId], references: [id])
  provider        CrmProvider?  @relation(fields: [providerId], references: [id])
  plan            PlanPlan?     @relation(fields: [planId], references: [id])

  // Invoice details
  invoiceNumber   String
  invoiceDate     DateTime
  receivedAt      DateTime      @default(now())

  // Amounts in cents
  subtotalCents   Int
  gstCents        Int           @default(0)
  totalCents      Int

  // AI extraction
  aiConfidence    Float?        // 0.0–1.0
  aiExtractedAt   DateTime?
  aiRawData       Json?         // Full Textract response

  // Auto-matching — provider/participant linked by the matching service
  matchConfidence Float?        // 0.0–1.0 confidence of the auto-match
  matchMethod     String?       // e.g. "ABN_EXACT", "EMAIL_EXACT", "EMAIL_DOMAIN", "HISTORICAL", "NDIS_NUMBER", "MANUAL"

  // S3 storage — REQ-011: stored in ap-southeast-2
  s3Key           String?       // Key in S3 bucket
  s3Bucket        String?

  // Processing state
  status          InvStatus     @default(RECEIVED)
  approvedById    String?
  approvedAt      DateTime?
  rejectedById    String?
  rejectedAt      DateTime?
  rejectionReason String?

  approvedBy      CoreUser?     @relation("ApprovedBy", fields: [approvedById], references: [id])
  rejectedBy      CoreUser?     @relation("RejectedBy", fields: [rejectedById], references: [id])

  // Email ingest — REQ-024
  sourceEmail     String?       // Sender address from inbound email
  textractJobId   String?       // Async Textract job ID (polled after processing)
  ingestSource    InvIngestSource? // How the invoice entered the system

  // Xero sync — REQ-019/REQ-023
  xeroInvoiceId   String?       // Xero Invoice GUID after sync
  xeroSyncedAt    DateTime?     // Timestamp of last successful Xero sync

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  deletedAt       DateTime?     // Soft delete — REQ-010

  lines           InvInvoiceLine[]
  claims          ClmClaim[]
  correspondence  CrmCorrespondence[]

  @@index([participantId])
  @@index([providerId])
  @@index([status])
  @@index([receivedAt])
  @@map("inv_invoices")
}

enum InvStatus {
  RECEIVED
  PROCESSING
  PENDING_REVIEW
  APPROVED
  REJECTED
  CLAIMED
  PAID
}

enum InvIngestSource {
  EMAIL   // Received via SES inbound email pipeline (REQ-024)
  MANUAL  // Entered manually by staff via the web UI
  API     // Submitted via external API (future)
}

model InvInvoiceLine {
  id              String          @id @default(cuid())
  invoiceId       String
  invoice         InvInvoice      @relation(fields: [invoiceId], references: [id])

  budgetLineId    String?
  budgetLine      PlanBudgetLine? @relation(fields: [budgetLineId], references: [id])

  // NDIS support item details
  supportItemCode String          // e.g. "15_042_0128_1_3"
  supportItemName String
  categoryCode    String
  serviceDate     DateTime
  quantity        Float
  unitPriceCents  Int
  totalCents      Int
  gstCents        Int             @default(0)

  // Validation
  isPriceGuideCompliant Boolean   @default(true)
  priceGuideMaxCents    Int?      // Max allowed per price guide

  claimLines      ClmClaimLine[]

  @@index([invoiceId])
  @@map("inv_invoice_lines")
}

// ─────────────────────────────────────────────
// CLAIMS MODULE — PRODA Integration
// ─────────────────────────────────────────────

model ClmClaim {
  id              String         @id @default(cuid())
  invoiceId       String
  invoice         InvInvoice     @relation(fields: [invoiceId], references: [id])

  // Sequential human-readable reference (CLM-2026-0001)
  claimReference  String         @unique

  // Direct participant link (denormalised for query efficiency)
  participantId   String?
  participant     CrmParticipant? @relation(fields: [participantId], references: [id])

  // PRODA reference
  prodaClaimId    String?        @unique
  prodaReference  String?

  // Batch grouping
  batchId         String?
  batch           ClmBatch?      @relation(fields: [batchId], references: [id])

  // Amounts in cents
  claimedCents    Int
  approvedCents   Int            @default(0)

  status          ClmStatus      @default(PENDING)
  submittedAt     DateTime?
  submittedById   String?
  submittedBy     CoreUser?      @relation("ClaimSubmittedBy", fields: [submittedById], references: [id])
  outcomeAt       DateTime?
  outcomeById     String?
  outcomeBy       CoreUser?      @relation("ClaimOutcomeBy", fields: [outcomeById], references: [id])
  outcomeNotes    String?

  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  lines           ClmClaimLine[]
  payments        BnkPayment[]

  @@index([status])
  @@index([invoiceId])
  @@index([participantId])
  @@index([batchId])
  @@map("clm_claims")
}

model ClmClaimLine {
  id              String      @id @default(cuid())
  claimId         String
  claim           ClmClaim    @relation(fields: [claimId], references: [id])

  invoiceLineId   String?     // Optional link to source invoice line
  invoiceLine     InvInvoiceLine? @relation(fields: [invoiceLineId], references: [id])

  // Direct link back to the source invoice (set on batch-generated claims).
  // Denormalised for efficient lookup without joining through invoice lines.
  sourceInvoiceId String?

  supportItemCode String
  supportItemName String
  categoryCode    String
  serviceDate     DateTime
  quantity        Float
  unitPriceCents  Int
  totalCents      Int
  gstCents        Int         @default(0)

  // Outcome (filled when PRODA responds)
  status          ClmStatus?
  approvedCents   Int?
  outcomeNotes    String?

  @@index([claimId])
  @@map("clm_claim_lines")
}

model ClmBatch {
  id            String        @id @default(cuid())
  batchNumber   String        @unique
  status        ClmBatchStatus @default(DRAFT)
  notes         String?

  claimCount    Int
  totalCents    Int

  submittedById String?
  submittedBy   CoreUser?     @relation("BatchSubmittedBy", fields: [submittedById], references: [id])
  submittedAt   DateTime?
  prodaBatchId  String?       // PRODA batch reference

  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  claims        ClmClaim[]

  @@index([status])
  @@map("clm_batches")
}

enum ClmBatchStatus {
  DRAFT
  SUBMITTED
}

enum ClmStatus {
  PENDING
  SUBMITTED
  APPROVED
  REJECTED
  PARTIAL
  PAID
}

// ─────────────────────────────────────────────
// BANKING MODULE — ABA Files, Reconciliation
// ─────────────────────────────────────────────

model BnkPayment {
  id            String     @id @default(cuid())
  claimId       String
  claim         ClmClaim   @relation(fields: [claimId], references: [id])

  // CBA ABA file details
  abaFileId     String?
  abaFile       BnkAbaFile? @relation(fields: [abaFileId], references: [id])

  amountCents   Int
  bsb           String
  accountNumber String
  accountName   String
  reference     String?

  status        BnkPaymentStatus @default(PENDING)
  processedAt   DateTime?

  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  @@index([status])
  @@map("bnk_payments")
}

enum BnkPaymentStatus {
  PENDING
  IN_ABA_FILE
  SUBMITTED_TO_BANK
  CLEARED
  FAILED
  REVERSED
}

model BnkAbaFile {
  id            String     @id @default(cuid())
  filename      String
  s3Key         String

  // Batch totals
  totalCents    Int
  paymentCount  Int

  // CBA CommBiz reference
  bankReference String?
  submittedAt   DateTime?
  clearedAt     DateTime?

  createdAt     DateTime   @default(now())

  payments      BnkPayment[]

  @@map("bnk_aba_files")
}

// ─────────────────────────────────────────────
// DOCUMENTS MODULE — File Storage
// ─────────────────────────────────────────────

enum DocCategory {
  SERVICE_AGREEMENT
  PLAN_LETTER
  INVOICE
  ASSESSMENT
  CORRESPONDENCE
  OTHER
}

model DocDocument {
  id            String      @id @default(cuid())
  participantId String?
  participant   CrmParticipant? @relation(fields: [participantId], references: [id])

  name          String
  description   String?
  category      DocCategory @default(OTHER)
  mimeType      String
  sizeBytes     Int
  s3Key         String
  s3Bucket      String

  // Versioning
  version       Int         @default(1)
  previousId    String?     // Points to prior version

  uploadedById  String
  uploadedBy    CoreUser    @relation("UploadedDocuments", fields: [uploadedById], references: [id])

  createdAt     DateTime    @default(now())
  deletedAt     DateTime?   // Soft delete — REQ-010

  @@index([participantId])
  @@index([uploadedById])
  @@index([category])
  @@map("doc_documents")
}

// ─────────────────────────────────────────────
// AUTOMATION MODULE — Rules, Triggers, Actions
// ─────────────────────────────────────────────

model AutoRule {
  id              String          @id @default(cuid())
  name            String
  description     String?
  isActive        Boolean         @default(true)

  // What kicks this off
  triggerType     AutoTriggerType
  triggerEvent    String?         // e.g. "lotus-pm.invoices.approved" (EVENT type)
  cronExpression  String?         // e.g. "0 9 * * *" (SCHEDULE type)

  // Conditions and actions stored as JSON arrays
  // See src/lib/modules/automation/types.ts for shapes
  conditions      Json            // AutoCondition[]
  actions         Json            // AutoAction[]

  // Stats
  lastTriggeredAt DateTime?
  executionCount  Int             @default(0)

  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  deletedAt       DateTime?       // Soft delete

  executions      AutoExecutionLog[]

  @@index([triggerType])
  @@index([isActive])
  @@map("auto_rules")
}

enum AutoTriggerType {
  EVENT    // Triggered by an EventBridge event
  SCHEDULE // Triggered on a cron schedule
}

model AutoExecutionLog {
  id           String              @id @default(cuid())
  ruleId       String
  rule         AutoRule            @relation(fields: [ruleId], references: [id])

  triggeredBy  String              // event name, "schedule", or "manual"
  context      Json                // The trigger payload

  result       AutoExecutionResult
  actionsRun   Int                 @default(0)
  errorMessage String?
  durationMs   Int?

  executedAt   DateTime            @default(now())

  @@index([ruleId])
  @@index([executedAt])
  @@map("auto_execution_logs")
}

enum AutoExecutionResult {
  SUCCESS  // All conditions met, all actions completed
  SKIPPED  // Conditions not met — rule did not fire
  FAILED   // Error during condition evaluation or action execution
}

// ─────────────────────────────────────────────
// NOTIFICATIONS MODULE — SMS, Email, In-App
// ─────────────────────────────────────────────

model NotifNotification {
  id            String           @id @default(cuid())
  channel       NotifChannel
  recipient     String           // Phone number (E.164), email, or user ID for IN_APP
  subject       String?          // For email notifications only
  message       String           @db.Text

  // Delivery tracking
  status        NotifStatus      @default(PENDING)
  externalId    String?          // ClickSend message_id or SES message ID
  errorMessage  String?
  sentAt        DateTime?

  // IN_APP read/dismiss tracking
  userId        String?          // Staff user this notification is for (IN_APP channel)
  user          CoreUser?        @relation("UserNotifications", fields: [userId], references: [id])
  readAt        DateTime?
  dismissedAt   DateTime?

  // Optional link to participants (REQ-010: 5-year retention)
  participantId String?
  participant   CrmParticipant?  @relation(fields: [participantId], references: [id])

  // Who triggered this notification (null = system/automation)
  triggeredById String?

  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  @@index([channel, status])
  @@index([participantId])
  @@index([userId, readAt])
  @@index([createdAt])
  @@map("notif_notifications")
}

enum NotifChannel {
  SMS
  EMAIL
  IN_APP
}

enum NotifStatus {
  PENDING
  SENT
  FAILED
  DELIVERED
  UNDELIVERED
}

// ─────────────────────────────────────────────
// XERO MODULE — Accounting Integration
// REQ-019/REQ-023: Two-way Xero sync (invoices, payments, reconciliation)
// ─────────────────────────────────────────────

model XeroConnection {
  id              String    @id @default(cuid())

  // Xero organisation/tenant (one connection per tenant)
  tenantId        String    @unique  // Xero Organisation GUID
  tenantName      String?            // Human-readable org name

  // OAuth2 tokens (stored encrypted — REQ-016)
  accessToken     String    @db.Text // Short-lived (30 min)
  refreshToken    String    @db.Text // Long-lived — used to get new access tokens
  tokenExpiresAt  DateTime           // When the access token expires

  // Granted scopes
  scopes          String[]  @default([])

  isActive        Boolean   @default(true)

  // Who connected this organisation
  connectedById   String
  connectedAt     DateTime  @default(now())

  // Sync tracking
  lastSyncAt      DateTime?
  syncErrorCount  Int       @default(0)
  lastSyncError   String?

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([isActive])
  @@map("xero_connections")
}
